function [b0differencePresort, reconstruction, phi_b0] = b0eddycorrect_xy(acquisition, reconstruction, options, b0axis)
% Reads files generated by C reconstruction. These data were acquired
% during the calibration portion of the scan to measure the variations in
% the B0 field due to eddy currents.
%
% INPUTS
%       acquisition         structure containing acquisition parameters
%       reconstruction      structure containing reconstruction parameters
%       options             options such as making figures or writing data
%       b0axis              integer value; [1] X-axis [2] Y-Axis. Signifies
%                           which axis the test gradient was played along
% OUTPUTS
%       b0differencePresort 
%       reconstruction      updated structure of reconstruction parameters
%       phi_b0              (array) Point-by-Point B0 Phase due to test 
%                           gradient played along specified axis

%% Message to user
switch(b0axis)

	case 1
		string_axis_label = 'first';

	case 2
		string_axis_label = 'second';

	otherwise
		string_axis_label = '';
end

fprintf(sprintf('Calculating B0-Eddy Current Phase corrections from %s test gradient. \n', string_axis_label ));

%% Scan parameters
xres                    = acquisition.xres;
% amp_gx                  = acquisition.ampx;
cal_ampmod              = acquisition.cal_ampmod;
filename_rotmats        = acquisition.rotmat_file;

if (b0axis == 1)
	filename_b0diffpresort  = strcat(acquisition.b0datapath_x, 'B0_DifferencePresort.dat');
elseif (b0axis == 2)
	filename_b0diffpresort  = strcat(acquisition.b0datapath_y, 'B0_DifferencePresort.dat');
end

%% Load 'B0_DifferencePresort.dat'
b0differencePresort_raw = open_floats(filename_b0diffpresort);
NumExperiments = length(b0differencePresort_raw) / xres;
b0differencePresort = reshape(b0differencePresort_raw, [xres NumExperiments]);
b0differencePresort = b0differencePresort / 4 / cal_ampmod;

if options.make_plots
    figure;
    imagesc(b0differencePresort); 
    title('Imagesc of b0DifferencePresort Data');

    dt = 1000/2/acquisition.BW; % microseconds
%     time = (0:xres-1)*dt;

    if b0axis == 1
        grad_str = 'Gx ';
    elseif b0axis == 2
        grad_str = 'Gy ';
    end
    
    figure; hold on;
    for kk = 1:3

        set(gcf, 'Color','w');
        
        switch(kk)

            case 1
                color_string = 'r';
            case 2 
                color_string = 'g';
            case 3
                color_string = 'b';
        end
        
        titlestring = sprintf('B0 Phase Accrual: iCone %s Tested on X,Y,Z Axes', grad_str);
%       plot(time, b0differencePresort(:,kk)*180/pi, color_string,'LineWidth',4);
        plot(b0differencePresort(:,kk)*180/pi, color_string,'LineWidth',4);
        str_title = sprintf(titlestring);
    end
    
    title(str_title,'FontSize',46,'FontName','Courier 10 Pitch');
    ylabel('Phase [degrees]','FontSize',40,'FontName','Courier 10 Pitch');
%     xlabel('Time [us]','FontSize',26,'FontName','Courier','FontWeight','Bold');
    xlabel('SAMPLE POINT','FontSize',40,'FontName','Courier 10 Pitch');
    handle_legend = legend('X','Y','Z');
    set(handle_legend,'FontSize',36,'FontName','Courier 10 Pitch', 'edgecolor','white');
    box off;
    hold off;
end
%% Determine Weights: Assumes only x-gradient is significant, so only use values from column 1 of each rotation matrix.

% Load Rotation Matrices
rotmats_raw = open_floats(filename_rotmats);
proj = length(rotmats_raw) / 9;
rotmats = reshape(rotmats_raw, [3 3 proj]);

% Extract Relevant Weights from Rotation Matrices (column 1 for x-Axis OR
% column 2 for Yaxis)
wts = reshape(rotmats(:,b0axis,:), [3 proj]);

% Apply b0 phase correction to data
% XINDEX = 1;
% YINDEX = 3;
% ZINDEX = 5;

% for latest psd build (i.e. 35)
XINDEX = 1;
YINDEX = 2;
ZINDEX = 3;

% PreAllocate Memory for B0-Phase array
phixyz_b0 = zeros(xres,3);

% B0 Phase from test gradient on XBoard
phixyz_b0(:,1) = b0differencePresort(:,XINDEX); % * amp_gx / cal_ampmod;

% B0 Phase from test gradient on YBoard
phixyz_b0(:,2) = b0differencePresort(:,YINDEX); % * amp_gx / cal_ampmod;

% B0 Phase from test gradient on ZBoard
phixyz_b0(:,3) = b0differencePresort(:,ZINDEX); % * amp_gx / cal_ampmod;

% Matrix Multiply the Measured B0 Phase Accumulation by the Weights (per projection)
if (isfield(acquisition,'acq_extra_points') && acquisition.acq_extra_points > 0)
    phixyz_b0 = phixyz_b0(reconstruction.data2use,:);        
end

phi_b0 = phixyz_b0 * wts;
%% Remove any undesired projections
[~, phi_b0] = RemoveProjectionData(phi_b0, acquisition.proj, reconstruction.proj2skip);

end
